import 'dart:io';

import 'package:path/path.dart' as path;

/// {@template configuration_generator}
/// A class which can be extended to generate code for a specific target
/// {@endtemplate}
class ConfigurationGenerator {
  /// {@macro configuration_generator}
  ConfigurationGenerator({
    required this.target,
  });

  /// The target file to generate code for
  final File target;

  /// The line comment symbol for the target file in its language.
  /// This is based on the file extension of the target file.
  String wrapLineComment(String value) {
    switch (path.extension(target.path)) {
      case '.dart':
        return '// $value';
      case '.gradle':
        return '// $value';
      case '.xcconfig':
        return '// $value';
      case '.yaml':
        return '# $value';
      case '.json':
        return '/* $value */';
      default:
        return '';
    }
  }

  /// The comment to be used to mark the start of generated code
  String get generatedCodeStartComment => wrapLineComment(
        'start of code generated by package:dart_define, DO NOT modify or remove these comments',
      );

  /// The comment to be used to mark the end of generated code
  String get generatedCodeEndComment => wrapLineComment(
        'end of code generated by package:dart_define, DO NOT modify or remove these comments',
      );

  String get generatedCodeWarning => wrapLineComment(
        'This file was generated by package:dart_define, DO NOT modify or remove these comments',
      );

  /// Wraps the given [content] with the generated code comments
  String wrapWithComments(String content) => '$generatedCodeWarning\n$content';

  /// Writes the given [content] to the target file.
  /// If the target file does not exist, it will be created.
  void writeTarget(String content, [File? file]) {
    file ??= target;
    if (!file.existsSync()) {
      file.createSync(recursive: true);
    }

    file.writeAsStringSync(
      content,
    );
  }

  /// Reads the target file as a string.
  /// If the target file does not exist, it will be created.
  String readTarget([File? file]) {
    file ??= target;
    if (!file.existsSync()) {
      file.createSync(recursive: true);
    }
    return file.readAsStringSync();
  }

  /// Deletes the generated code from the target file. This will only
  /// delete the code between the generated code comments.
  void deleteGeneratedCode([File? file]) {
    file ??= target;
    final content = readTarget(file)
      ..replaceAll(
        RegExp(
          '$generatedCodeStartComment.*$generatedCodeEndComment',
          multiLine: true,
          dotAll: true,
          caseSensitive: false,
        ),
        '',
      );

    writeTarget(
      content,
      file,
    );
  }

  /// Generates the code for the target file. This method shall be implemented
  /// by a subclass of [ConfigurationGenerator].
  void generate() {
    throw UnimplementedError(
      'generate() must be implemented in a subclass of ConfigurationGenerator',
    );
  }
}
