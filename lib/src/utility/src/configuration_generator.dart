import 'dart:io';

import 'package:path/path.dart' as path;

/// {@template configuration_generator}
/// A class which can be extended to generate code for a specific target
/// {@endtemplate}
class ConfigurationGenerator {
  /// {@macro configuration_generator}
  ConfigurationGenerator({
    required this.target,
  });

  /// The target file to generate code for
  final File target;

  /// The line comment symbol for the target file in its language.
  /// This is based on the file extension of the target file.
  String wrapLineComment(String value) {
    switch (path.extension(target.path)) {
      case '.dart':
        return '// $value';
      case '.gradle':
        return '// $value';
      case '.xcconfig':
        return '// $value';
      case '.yaml':
        return '# $value';
      case '.json':
        return '/* $value */';
      case '':

        /// dotfiles won't return the extension, but an empty string
        switch (path.basename(target.path)) {
          case '.gitignore':
            return '# $value';
        }
    }

    return value;
  }

  /// The comment to be used to mark the start of generated code
  String get generatedCodeStartComment => wrapLineComment(
        'start of code generated by package:dart_define, DO NOT modify or remove these comments',
      );

  /// The comment to be used to mark the end of generated code
  String get generatedCodeEndComment => wrapLineComment(
        'end of code generated by package:dart_define, DO NOT modify or remove these comments',
      );

  String get generatedCodeWarning => wrapLineComment(
        'This file was generated by package:dart_define, DO NOT modify or remove these comments',
      );

  /// Wraps the given [content] with the generated code comments
  String wrapWithComments(String content) => '$generatedCodeWarning\n$content';

  /// Writes the given [content] to the target file.
  /// If the target file does not exist, it will be created.
  void writeTarget(String content, [File? file]) {
    file ??= target;
    if (!file.existsSync()) {
      file.createSync(recursive: true);
    }

    file.writeAsStringSync(
      content,
    );
  }

  /// Reads the target file as a string.
  /// If the target file does not exist, it will be created.
  String readTarget([File? file]) {
    file ??= target;
    if (!file.existsSync()) {
      file.createSync(recursive: true);
    }

    return file.readAsStringSync();
  }

  /// Deletes the generated code from the target file. This will only
  /// delete the code between the generated code comments.
  void deleteGeneratedCode([File? file]) {
    file ??= target;
    final content = readTarget(file)
      ..replaceAll(
        RegExp(
          '$generatedCodeStartComment.*$generatedCodeEndComment',
          multiLine: true,
          dotAll: true,
          caseSensitive: false,
        ),
        '',
      );

    writeTarget(
      content,
      file,
    );
  }

  /// Appends to the generated code section surrounded by start and end comments
  void appendGeneratedCode(String code, [File? file]) {
    file ??= target;
    final generatedRegex = RegExp(
      '$generatedCodeStartComment(.*)$generatedCodeEndComment',
      multiLine: true,
      dotAll: true,
      caseSensitive: false,
    );

    final content = readTarget(file);
    final match = generatedRegex.firstMatch(content);

    final previouseCode = match?[1] ?? '';

    if (previouseCode.contains('\n$code\n')) {
      return;
    }

    final newContent = [
      content.replaceAll(generatedRegex, ''),
      generatedCodeStartComment,
      previouseCode.trim(),
      code.trim(),
      generatedCodeEndComment,
    ].where((i) => i.isNotEmpty).join('\n');

    writeTarget(newContent, file);
  }

  /// Generates the code for the target file. This method shall be implemented
  /// by a subclass of [ConfigurationGenerator].
  void generate() {
    throw UnimplementedError(
      'generate() must be implemented in a subclass of ConfigurationGenerator',
    );
  }
}
